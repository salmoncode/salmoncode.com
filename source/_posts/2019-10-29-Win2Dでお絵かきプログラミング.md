---
title: Win2Dでお絵かきプログラミング
date: 2019-10-29 16:36:29
category: プログラミング
tags:
  - C#
  - Win2D
---

過去記事の再掲です。

## はじめに

僕は普段、簡単なプログラミングには Processing を使っている。
java 使えるし、見た目のあるアプリケーションを簡単に開発できるので気に入っている。
ところで、最近 WindowsAPI を使って開発したいものがあった。こういうものは VisualStudio を使って C#で作るのがよい。

さて、Windows の GUI 開発にはいくつか種類があって、「フォームアプリケーション」とか WPF とか UWP とかある。
新しいのが UWP で、センサーの値を拾ったりするのが簡単である。見た目の部分は xaml を使って描くらしい。
GUI の部品はある程度用意されており、デザイナーの使い勝手もとてもいい。ただ前述のとおり Processing が好きな僕は、できれば UWP でも簡単に図形を描画したりしたい。

そんな願いを叶えてくれるのが、Microsoft が出している(!)Win2D というライブラリである。 簡単に説明すると、DirectX のラッパーである。

<!-- more -->

## 導入

「ファイル」→「新規作成」→「プロジェクト」から「空のアプリケーション」を選択。

<img class="hatena-fotolife" title="f:id:salmon2073:20160314115327p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/salmon2073/20160314/20160314115327.png" alt="f:id:salmon2073:20160314115327p:plain">

新しいプロジェクトが開いたら、「ツール」→「NuGet パッケージマネージャー」→「ソリューションの NuGet パッケージの管理」と進み、 「参照」タブを選択。検索バーに win2d と入力するといくつか候補が出てくる。 赤いアイコンのやつがうまく動いてくれるので、win10 の人は基本的に「Win2D.uwp」を選択してインストール。プロジェクト作成時に(Windows8.1)と表示された人は「Win2D.wiin81」を選択しよう。

<img class="hatena-fotolife" title="f:id:salmon2073:20160314120116p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/salmon2073/20160314/20160314120116.png" alt="f:id:salmon2073:20160314120116p:plain">

## Win2d の初期設定

公式ドキュメントに使い方が載っている。

<a href="https://microsoft.github.io/Win2D/html/Introduction.htm">Introduction</a>

MainPage.xaml の Page タグの中に以下の文を書き込み、

<pre class="code" data-lang="" data-unlink="">xmlns:canvas="using:Microsoft.Graphics.Canvas.UI.Xaml"</pre>

Grid タグの中に以下の文を書き込めばよい。

<pre class="code" data-lang="" data-unlink="">&lt;canvas:CanvasControl Draw="CanvasControl_Draw" ClearColor="White" Loaded="CanvasControl_Loaded"/&gt;</pre>

MainPage.xaml.cs にセットアップ用のメソッドと描画用のメソッドを実装する。 最低限動くコードは以下の通り。

<pre class="code lang-cs" data-lang="cs" data-unlink=""><span class="synStatement">using</span> Microsoft.Graphics.Canvas;
<span class="synStatement">using</span> Microsoft.Graphics.Canvas.UI.Xaml;
<span class="synStatement">using</span> Windows.UI.Xaml;
<span class="synStatement">using</span> Windows.UI.Xaml.Controls;

<span class="synType">namespace</span> App2
{
    <span class="synType">public</span> <span class="synType">sealed</span> <span class="synStatement">partial</span> <span class="synType">class</span> MainPage : Page
    {
        <span class="synType">public</span> MainPage()
        {
            <span class="synStatement">this</span>.InitializeComponent();
        }

        <span class="synType">private</span> <span class="synType">void</span> CanvasControl_Loaded(<span class="synType">object</span> sender, RoutedEventArgs e) {

        }

        <span class="synType">private</span> <span class="synType">void</span> CanvasControl_Draw(CanvasControl sender, CanvasDrawEventArgs args) {
            CanvasDrawingSession d = args.DrawingSession;
            <span class="synComment">/*ここに描画命令を書く*/</span>
        }
    }
}

</pre>

プロセッサアーキテクチャが云々言われたら AnyCPU から他のものに変えよう。 ここまでくると processing とそっくりなので書きやすい。

## 図形の描画

args から DrawingSession を取り出して描画命令を呼び出す。 簡単な命令をいくつか。

<pre class="code lang-cs" data-lang="cs" data-unlink=""><span class="synStatement">using</span> Microsoft.Graphics.Canvas;
<span class="synStatement">using</span> Microsoft.Graphics.Canvas.Text;
<span class="synStatement">using</span> Microsoft.Graphics.Canvas.UI.Xaml;
<span class="synStatement">using</span> Windows.UI;
<span class="synStatement">using</span> Windows.UI.Xaml;
<span class="synStatement">using</span> Windows.UI.Xaml.Controls;

<span class="synType">namespace</span> App2 {
    <span class="synType">public</span> <span class="synType">sealed</span> <span class="synStatement">partial</span> <span class="synType">class</span> MainPage : Page {
        <span class="synType">public</span> MainPage() {
            <span class="synStatement">this</span>.InitializeComponent();
        }

        <span class="synType">private</span> <span class="synType">void</span> CanvasControl_Loaded(<span class="synType">object</span> sender, RoutedEventArgs e) {

        }

        <span class="synType">private</span> <span class="synType">void</span> CanvasControl_Draw(CanvasControl sender, CanvasDrawEventArgs args) {
            CanvasDrawingSession d = args.DrawingSession;
            d.FillRectangle(<span class="synConstant">250</span>, <span class="synConstant">250</span>, <span class="synConstant">700</span>, <span class="synConstant">400</span>, Color.FromArgb(<span class="synConstant">50</span>, <span class="synConstant">100</span>, <span class="synConstant">50</span>, <span class="synConstant">250</span>));
            d.DrawEllipse(<span class="synConstant">450</span>, <span class="synConstant">450</span>, <span class="synConstant">200</span>, <span class="synConstant">200</span>, Color.FromArgb(<span class="synConstant">100</span>, <span class="synConstant">100</span>, <span class="synConstant">100</span>, <span class="synConstant">255</span>));
            d.FillEllipse(<span class="synConstant">750</span>, <span class="synConstant">450</span>, <span class="synConstant">200</span>, <span class="synConstant">200</span>, Color.FromArgb(<span class="synConstant">100</span>, <span class="synConstant">100</span>, <span class="synConstant">100</span>, <span class="synConstant">255</span>));
            CanvasTextFormat f = <span class="synStatement">new</span> CanvasTextFormat();
            f.FontSize = <span class="synConstant">30</span>;
            d.DrawText(<span class="synConstant">"Hello World!"</span>, <span class="synConstant">370</span>, <span class="synConstant">430</span>, Color.FromArgb(<span class="synConstant">200</span>, <span class="synConstant">255</span>, <span class="synConstant">255</span>, <span class="synConstant">255</span>),f);
        }
    }
}
</pre>

実行するとこんな感じ

<img class="hatena-fotolife" title="f:id:salmon2073:20160314134044p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/salmon2073/20160314/20160314134044.png" alt="f:id:salmon2073:20160314134044p:plain">

そういえば、ウィンドウの縦横情報を取得する方法が分からなくて困った。こんな感じに取得できる。

<pre class="code lang-cs" data-lang="cs" data-unlink="">var width = sender.Size.Width;
var hight = sender.Size.Height;
</pre>

## アニメーションをつくる

Introduction のコードは静止したスケッチを描くようなので、アニメーションをしようと思ったら canvas を以下のように書き換える。

<pre class="code" data-lang="" data-unlink="">&lt;canvas:CanvasAnimatedControl x:Name="canvas" Draw="canvas_DrawAnimated" ClearColor="White"  CreateResources="canvas_CreateResources"/&gt;
</pre>

コードのほうも少し変える。

<pre class="code lang-cs" data-lang="cs" data-unlink=""><span class="synStatement">using</span> Microsoft.Graphics.Canvas;
<span class="synStatement">using</span> Microsoft.Graphics.Canvas.UI;
<span class="synStatement">using</span> Microsoft.Graphics.Canvas.UI.Xaml;
<span class="synStatement">using</span> Windows.UI.Xaml;
<span class="synStatement">using</span> Windows.UI.Xaml.Controls;

<span class="synType">namespace</span> App3 {
    <span class="synType">public</span> <span class="synType">sealed</span> <span class="synStatement">partial</span> <span class="synType">class</span> MainPage : Page {
        <span class="synType">public</span> MainPage() {
            <span class="synStatement">this</span>.InitializeComponent();
        }

        <span class="synType">private</span> <span class="synType">void</span> canvas_Loaded(<span class="synType">object</span> sender, RoutedEventArgs e) {

        }

        <span class="synType">private</span> <span class="synType">void</span> canvas_CreateResources(CanvasAnimatedControl sender, CanvasCreateResourcesEventArgs args) {

        }

        <span class="synType">private</span> <span class="synType">void</span> canvas_DrawAnimated(ICanvasAnimatedControl sender, CanvasAnimatedDrawEventArgs args) {
            CanvasDrawingSession d = args.DrawingSession;
        }
    }
}
</pre>

## おわりに

意外と日本語の情報が少なかった。 本来はもっといろんな CG 処理を描けるものらしいので、気が向いたらやってみる。

<a href="https://microsoft.github.io/Win2D/html/Introduction.htm"></a><a href="https://microsoft.github.io/Win2D/html/Introduction.htm"></a>
