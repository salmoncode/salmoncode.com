---
title: Win2Dでお絵かきプログラミング
date: 2019-10-30 16:36:29
tags:
---

過去記事の再掲です。

## はじめに

僕は普段、簡単なプログラミングにはProcessingを使っている。
java使えるし、見た目のあるアプリケーションを簡単に開発できるので気に入っている。
ところで、最近WindowsAPIを使って開発したいものがあった。こういうものはVisualStudioを使ってC#で作るのがよい。

さて、WindowsのGUI開発にはいくつか種類があって、「フォームアプリケーション」とかWPFとかUWPとかある。
新しいのがUWPで、センサーの値を拾ったりするのが簡単である。見た目の部分はxamlを使って描くらしい。
GUIの部品はある程度用意されており、デザイナーの使い勝手もとてもいい。ただ前述のとおりProcessingが好きな僕は、できればUWPでも簡単に図形を描画したりしたい。

そんな願いを叶えてくれるのが、Microsoftが出している(!)Win2Dというライブラリである。 簡単に説明すると、DirectXのラッパーである。

<!-- more -->

## 導入

「ファイル」→「新規作成」→「プロジェクト」から「空のアプリケーション」を選択。

<img class="hatena-fotolife" title="f:id:salmon2073:20160314115327p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/salmon2073/20160314/20160314115327.png" alt="f:id:salmon2073:20160314115327p:plain">

新しいプロジェクトが開いたら、「ツール」→「NuGetパッケージマネージャー」→「ソリューションのNuGetパッケージの管理」と進み、 「参照」タブを選択。検索バーにwin2dと入力するといくつか候補が出てくる。 赤いアイコンのやつがうまく動いてくれるので、win10の人は基本的に「Win2D.uwp」を選択してインストール。プロジェクト作成時に(Windows8.1)と表示された人は「Win2D.wiin81」を選択しよう。

<img class="hatena-fotolife" title="f:id:salmon2073:20160314120116p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/salmon2073/20160314/20160314120116.png" alt="f:id:salmon2073:20160314120116p:plain">

## Win2dの初期設定

公式ドキュメントに使い方が載っている。

<a href="https://microsoft.github.io/Win2D/html/Introduction.htm">Introduction</a>

MainPage.xamlのPageタグの中に以下の文を書き込み、
<pre class="code" data-lang="" data-unlink="">xmlns:canvas="using:Microsoft.Graphics.Canvas.UI.Xaml"</pre>
Gridタグの中に以下の文を書き込めばよい。
<pre class="code" data-lang="" data-unlink="">&lt;canvas:CanvasControl Draw="CanvasControl_Draw" ClearColor="White" Loaded="CanvasControl_Loaded"/&gt;</pre>
MainPage.xaml.csにセットアップ用のメソッドと描画用のメソッドを実装する。 最低限動くコードは以下の通り。
<pre class="code lang-cs" data-lang="cs" data-unlink=""><span class="synStatement">using</span> Microsoft.Graphics.Canvas;
<span class="synStatement">using</span> Microsoft.Graphics.Canvas.UI.Xaml;
<span class="synStatement">using</span> Windows.UI.Xaml;
<span class="synStatement">using</span> Windows.UI.Xaml.Controls;

<span class="synType">namespace</span> App2
{
    <span class="synType">public</span> <span class="synType">sealed</span> <span class="synStatement">partial</span> <span class="synType">class</span> MainPage : Page
    {
        <span class="synType">public</span> MainPage()
        {
            <span class="synStatement">this</span>.InitializeComponent();
        }

        <span class="synType">private</span> <span class="synType">void</span> CanvasControl_Loaded(<span class="synType">object</span> sender, RoutedEventArgs e) {

        }

        <span class="synType">private</span> <span class="synType">void</span> CanvasControl_Draw(CanvasControl sender, CanvasDrawEventArgs args) {
            CanvasDrawingSession d = args.DrawingSession;
            <span class="synComment">/*ここに描画命令を書く*/</span>
        }
    }
}

</pre>
プロセッサアーキテクチャが云々言われたらAnyCPUから他のものに変えよう。 ここまでくるとprocessingとそっくりなので書きやすい。

## 図形の描画

argsからDrawingSessionを取り出して描画命令を呼び出す。 簡単な命令をいくつか。
<pre class="code lang-cs" data-lang="cs" data-unlink=""><span class="synStatement">using</span> Microsoft.Graphics.Canvas;
<span class="synStatement">using</span> Microsoft.Graphics.Canvas.Text;
<span class="synStatement">using</span> Microsoft.Graphics.Canvas.UI.Xaml;
<span class="synStatement">using</span> Windows.UI;
<span class="synStatement">using</span> Windows.UI.Xaml;
<span class="synStatement">using</span> Windows.UI.Xaml.Controls;

<span class="synType">namespace</span> App2 {
    <span class="synType">public</span> <span class="synType">sealed</span> <span class="synStatement">partial</span> <span class="synType">class</span> MainPage : Page {
        <span class="synType">public</span> MainPage() {
            <span class="synStatement">this</span>.InitializeComponent();
        }

        <span class="synType">private</span> <span class="synType">void</span> CanvasControl_Loaded(<span class="synType">object</span> sender, RoutedEventArgs e) {

        }

        <span class="synType">private</span> <span class="synType">void</span> CanvasControl_Draw(CanvasControl sender, CanvasDrawEventArgs args) {
            CanvasDrawingSession d = args.DrawingSession;
            d.FillRectangle(<span class="synConstant">250</span>, <span class="synConstant">250</span>, <span class="synConstant">700</span>, <span class="synConstant">400</span>, Color.FromArgb(<span class="synConstant">50</span>, <span class="synConstant">100</span>, <span class="synConstant">50</span>, <span class="synConstant">250</span>));
            d.DrawEllipse(<span class="synConstant">450</span>, <span class="synConstant">450</span>, <span class="synConstant">200</span>, <span class="synConstant">200</span>, Color.FromArgb(<span class="synConstant">100</span>, <span class="synConstant">100</span>, <span class="synConstant">100</span>, <span class="synConstant">255</span>));
            d.FillEllipse(<span class="synConstant">750</span>, <span class="synConstant">450</span>, <span class="synConstant">200</span>, <span class="synConstant">200</span>, Color.FromArgb(<span class="synConstant">100</span>, <span class="synConstant">100</span>, <span class="synConstant">100</span>, <span class="synConstant">255</span>));
            CanvasTextFormat f = <span class="synStatement">new</span> CanvasTextFormat();
            f.FontSize = <span class="synConstant">30</span>;
            d.DrawText(<span class="synConstant">"Hello World!"</span>, <span class="synConstant">370</span>, <span class="synConstant">430</span>, Color.FromArgb(<span class="synConstant">200</span>, <span class="synConstant">255</span>, <span class="synConstant">255</span>, <span class="synConstant">255</span>),f);
        }
    }
}
</pre>
実行するとこんな感じ

<img class="hatena-fotolife" title="f:id:salmon2073:20160314134044p:plain" src="https://cdn-ak.f.st-hatena.com/images/fotolife/s/salmon2073/20160314/20160314134044.png" alt="f:id:salmon2073:20160314134044p:plain">

そういえば、ウィンドウの縦横情報を取得する方法が分からなくて困った。こんな感じに取得できる。
<pre class="code lang-cs" data-lang="cs" data-unlink="">var width = sender.Size.Width;
var hight = sender.Size.Height;
</pre>

## アニメーションをつくる

Introductionのコードは静止したスケッチを描くようなので、アニメーションをしようと思ったらcanvasを以下のように書き換える。
<pre class="code" data-lang="" data-unlink="">&lt;canvas:CanvasAnimatedControl x:Name="canvas" Draw="canvas_DrawAnimated" ClearColor="White"  CreateResources="canvas_CreateResources"/&gt;
</pre>
コードのほうも少し変える。
<pre class="code lang-cs" data-lang="cs" data-unlink=""><span class="synStatement">using</span> Microsoft.Graphics.Canvas;
<span class="synStatement">using</span> Microsoft.Graphics.Canvas.UI;
<span class="synStatement">using</span> Microsoft.Graphics.Canvas.UI.Xaml;
<span class="synStatement">using</span> Windows.UI.Xaml;
<span class="synStatement">using</span> Windows.UI.Xaml.Controls;

<span class="synType">namespace</span> App3 {
    <span class="synType">public</span> <span class="synType">sealed</span> <span class="synStatement">partial</span> <span class="synType">class</span> MainPage : Page {
        <span class="synType">public</span> MainPage() {
            <span class="synStatement">this</span>.InitializeComponent();
        }

        <span class="synType">private</span> <span class="synType">void</span> canvas_Loaded(<span class="synType">object</span> sender, RoutedEventArgs e) {

        }

        <span class="synType">private</span> <span class="synType">void</span> canvas_CreateResources(CanvasAnimatedControl sender, CanvasCreateResourcesEventArgs args) {

        }

        <span class="synType">private</span> <span class="synType">void</span> canvas_DrawAnimated(ICanvasAnimatedControl sender, CanvasAnimatedDrawEventArgs args) {
            CanvasDrawingSession d = args.DrawingSession;
        }
    }
}
</pre>

## おわりに

意外と日本語の情報が少なかった。 本来はもっといろんなCG処理を描けるものらしいので、気が向いたらやってみる。

<a href="https://microsoft.github.io/Win2D/html/Introduction.htm"></a><a href="https://microsoft.github.io/Win2D/html/Introduction.htm"></a>